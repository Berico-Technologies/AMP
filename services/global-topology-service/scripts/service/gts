#!/bin/bash
#
# gts 
#
# chkconfig: 345 99 99
# description: ampere security service
#
# Configuration Files
# /etc/default/gts
#
# Configuration variables
# JAVA_OPTS

# Source function library.
. /etc/rc.d/init.d/functions

prog="gts"
config="/etc/ampere/$prog/gts-x509.yaml"
JAR="/opt/ampere/$prog/gts-3.2.1.jar"
ARGS="server $config"
serviceUser="gts"
serviceGroup="gts"
maxShutdownTime=15

[ -e /etc/default/$prog ] && . /etc/default/$prog

JAVA_HOME=/usr/java/latest
javaCommand=$JAVA_HOME/bin/java


lockfile=/var/lock/subsys/$prog
pidfile=/var/run/$prog

# Returns 0 when the service is running and sets the variable $pid to the PID.
getServicePID() {
  if [ ! -f $pidfile ]; then return 1; fi
  pid="$(<$pidfile)"
  checkProcessIsRunning $pid || return 1
  checkProcessIsOurService $pid || return 1
  return 0; 
}


# Makes the file $1 writable by the group $serviceGroup.
makeFileWritable() {
   local filename="$1"
   touch $filename || return 1
   chgrp $serviceGroup $filename || return 1
   chmod g+w $filename || return 1
   return 0; 
 }



startServiceProcess() {
   #cd $applDir || return 1
   #rm -f $pidFile
   makeFileWritable $pidfile || return 1
   #makeFileWritable $serviceLogFile || return 1
   cmd="nohup $javaCommand $JAVA_OPTS -jar $JAR $ARGS >> /dev/null 2>&1 & echo \$! > $pidfile"
   su -m $serviceUser -s $SHELL -c "$cmd" || return 1
   sleep 0.1
   pid="$(<$pidfile)"
   if checkProcessIsRunning $pid; then :; else
      echo -ne "\n$serviceName start failed, see logfile."
      return 1
   fi
   touch $lockfile
   return 0; 
}

# Returns 0 if the process with PID $1 is running.
checkProcessIsRunning() {
   local pid="$1"
   if [ -z "$pid" -o "$pid" == " " ]; then return 1; fi
   if [ ! -e /proc/$pid ]; then return 1; fi
   return 0; 
}

# Returns 0 if the process with PID $1 is our Java service process.
checkProcessIsOurService() {
   local pid="$1"
   if [ "$(ps -p $pid --no-headers -o comm)" != "java" ]; then return 1; fi
   grep -q --binary -F "$prog" /proc/$pid/cmdline
   if [ $? -ne 0 ]; then return 1; fi
   return 0; 
}

 stopServiceProcess() {
   kill $pid || return 1
   for ((i=0; i<maxShutdownTime*10; i++)); do
      checkProcessIsRunning $pid
      if [ $? -ne 0 ]; then
         rm -f $pidfile && rm -f $lockfile
         return 0
         fi
      sleep 0.1
      done
   echo -e "\n$serviceName did not terminate within $maxShutdownTime seconds, sending SIGKILL..."
   kill -s KILL $pid || return 1
   local killWaitTime=15
   for ((i=0; i<killWaitTime*10; i++)); do
      checkProcessIsRunning $pid
      if [ $? -ne 0 ]; then
         rm -f $pidFile && rm -f $lockfile
         return 0
         fi
      sleep 0.1
      done
   echo "Error: $serviceName could not be stopped within $maxShutdownTime+$killWaitTime seconds!"
   return 1; 
}


start() {
    #[ -x $exec ] || exit 5
   [ -f $config ] || exit 6
   getServicePID
   if [ $? -eq 0 ]; then echo -n "$prog is already running"; RETVAL=0; return 0; fi
   echo -n "Starting $prog   "
   startServiceProcess
   if [ $? -ne 0 ]; then RETVAL=1; echo "failed"; return 1; fi
   echo_success
   echo
   RETVAL=0
   return 0;
}

stop() {
    getServicePID
    if [ $? -ne 0 ]; then echo -n "$prog is not running"; RETVAL=0; echo ""; return 0; fi
    echo -n "Stopping $prog   "
    stopServiceProcess
    if [ $? -ne 0 ]; then RETVAL=1; echo "failed"; return 1; fi
    echo_success
    echo
    RETVAL=0
    return 0; 
}

restart() {
    stop
    start
}

reload() {
    restart
}

force_reload() {
    restart
}

rh_status() {
   echo -n "Checking for $serviceName:   "
   if getServicePID; then
    echo "running PID=$pid"
    RETVAL=0
   else
    echo "stopped"
    RETVAL=3
   fi
   return 0; 
}

rh_status_q() {
    rh_status >/dev/null 2>&1
}


case "$1" in
    start)
        #rh_status_q && exit 0
        $1
        ;;
    stop)
        #rh_status_q || exit 0
        $1
        ;;
    restart)
        $1
        ;;
    status)
        rh_status
        ;;
    *)
        echo $"Usage: $0 {start|stop|status|restart}"
        exit 2
esac
exit $?
